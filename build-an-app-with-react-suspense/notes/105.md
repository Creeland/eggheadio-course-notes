## Wrap Fetch Requests to Communicate Pending, Error and Success Status to React Suspense

An important concept to keep in mind is that every Promise can be wrapped to communicate the status to the boundaries. In this lesson we will wrap the [ðŸ“„ fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) returned promise to enable the communication with Error and Suspense Boundary.

To do this we will work on the `pokemon-detail.js` component file. This file have an static component that we will refactor to make it dynamic by consuming the data from [ðŸ›  pokeapi](https://pokeapi.co). In this case we will use the **bulbasaur** data that can be found at https://pokeapi.co/api/v2/pokemon/1.

To retrieve the data we will start by using the [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) API that is an interface for fetching resources available in the browser and use the Promise api to return the different states of the request. The fetch call will return a [ðŸ“„ Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) interface that represents the data obtained by the request. To get the data that we want from the **Reponse** interface we need to call the method `.json()` on it. This methods takes the Response stream and reads it, it also returns a promise that resolves with the result of parsing the Response body. 

> Do not forget to call `response.json()` after the fetch call is resolved.

```javascript
let pokemon = fetch("https://pokeapi.co/api/v2/pokemon/1").then(res => res.json() );
```

To enable this fetch promise to be read by the Suspense and Error Boundaries we need to create a wrapper around it.  `React.Lazy` is a wrapper but around `import` calls, so we need to create a new one for the data fetching use case.
This function, call `suspensify` need to manage the 3 statuses mentioned in the [last lesson](./104.md): **pending**, **rejected** and **resolved**

To understand how to write this wrapper we can fake the function handle each of the status, for resolved it will just return an object and for rejected will just throw an error. And finally need to manage the pending status by throwing the promise.

Then, in the `suspensify` function we need to manage each of the statuses by using conditional blocks.
```javascript
function suspensify(promise) {
    let status = 'error';
    if(status === 'pending') throw promise 
    if(status === 'error') throw Error;
    if(status === 'success) return { name: 'Fake bulbasaur'};
}
```

Now we need to write reject and resolve handlers for the promise. To do this we will chain an event to it and will use two callbacks. One that will be triggered when the promise resolves and one when the promise is rejected.

In case that the promise resolved, then we want to change the status to `success`and in case of rejection will change the status from `pending` to `error`.

```javascript
function suspensify(promise) {
    let status = 'pending';
    let suspender = promise.then(
        response => {
            status = "success";
        },
        error => {
            status = "error"
    });
    if(status === 'pending') throw suspender 
    if(status === 'error') throw Error;
    if(status === 'success) return { name: 'Fake bulbasaur'};
}
```
One gotcha of this approach is that the function is only call once, we need to give to the component a function to call when the promise is resolved, by convention this function is called `read` the implementation of this will wrap the conditional block of the function suspensify.

```javascript
function suspensify(promise) {
    let status = 'pending';
    let suspender = promise.then(
        response => {
            status = "success";
        },
        error => {
            status = "error"
    });
    return {
        read() {
            if(status === 'pending') throw suspender 
            if(status === 'error') throw Error;
            if(status === 'success) return { name: 'Fake bulbasaur'};

        }
    }  
}
```
With this in place, the component re-renders itself when the status of the promise changes, but the content rendered is still static, to fix this we need to return the result of the promise wrapped by the `suspender`. To do that we just create a new variable called `result` and append the respose of the promise to it.

```javascript
function suspensify(promise) {
    let status = 'pending';
    let result
    let suspender = promise.then(
        response => {
            status = "success";
            result = response
        },
        error => {
            status = "error"
            result = error
        }
    );
    return {
        read() {
            if(status === 'pending') throw suspender 
            if(status === 'error') throw result;
            if(status === 'success) return result;
        }
    }  
}
```
Now, when the component renders will trigger the fetch call that will immediatly goes to **pending** status and if is successfully resolved, will show the content that was requested.

ðŸ”® This *+suspensify** function is required now that the Suspense implementation is still experimental but still is something that need be wrote just once. 